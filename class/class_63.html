<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>将多个网格合并成一个网格</title>

    <style>
        html, body{
            margin: 0;
            height: 100%;
        }

        canvas {
            display: block;
        }
    </style>

</head>
<body onload="draw();">
    
</body>

<script src="../js/threejs/three.js"></script>
<script src="../js/threejs/OrbitControls.js"></script>
<script src="../js/threejs/Stats.js"></script>
<script src="../js/threejs/dat.gui.js"></script>

<script>

    var renderer;

    function initRender() {

        renderer = new THREE.WebGLRenderer({antialias: true});

        // renderer.setClearColor(new THREE.Color(0xEEEEEE)); //设置背景颜色

        renderer.setSize(window.innerWidth, window.innerHeight);

        //告诉渲染器需要阴影效果

        renderer.shadowMap.enabled = true;

        renderer.shadowMap.type = THREE.PCFSoftShadowMap; //默认点的，没有这个设置的清晰

        document.body.appendChild(renderer.domElement);

    }

    var camera;

    function initCamera() {

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000);

        camera.position.set(0, 40, 100);

        camera.lookAt(new THREE.Vector3(0, 0, 0));

    }

    var scene;

    function initScene() {

        scene = new THREE.Scene();

    }

    var light;

    function initLight() {

        scene.add(new THREE.AmbientLight(0x444444));

        light = new THREE.DirectionalLight(0xffffff);

        light.position.set(15, 50, 10);

        //告诉平行光需要开启阴影投影

        light.castShadow = true;

        scene.add(light);

    }

    var sphere, cube;

    function initModel() {

        //轴辅助 （每一个轴的长度）

        var helper = new THREE.AxesHelper(50);

        scene.add(helper);

        return;

    }

    //随机颜色

    function randomColor() {

        var arrHex = ["0","1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d","e","f"],

        strHex = "#",

        index;

        for (var i = 0; i < 6; i++) {

            index = Math.round(Math.random() * 15);

            strHex += arrHex[index];

        }

        return strHex;

    }

    //声明raycaster和mouse变量

    var raycaster = new THREE.Raycaster();

    var mouse = new THREE.Vector2();

    function onMouseClick (event) {

        //通过鼠标点击的位置计算出raycaster所需要的点的位置，以屏幕中心为原点，值的范围为-1到1。

        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;

        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        //通过鼠标点的位置和当前相机的矩阵计算出raycaster

        raycaster.setFromCamera( mouse, camera );

        //获取raycaster直线和所有模型相交的数组集合

        var intersects = raycaster.intersectObjects( scene.children );

        // console.log( intersects );

        //将所有的相交模型的颜色设置为红色，如果只需将第一个触发事件，那就将数组的第一个模型改变颜色即可

        for ( var i = 0; i < intersects.length; i++ ) {

            intersects[i].object.material.color.set( 0xff0000 );

        }

    }

    window.addEventListener( 'click', onMouseClick, false );

    //初始化性能插件

    var stats;

    function initStats() {

        stats = new Stats();

        document.body.appendChild(stats.domElement);

    }

    //用户交互插件 鼠标左键按住旋转，右键按住平移，滚轮缩放

    var controls;

    function initControls() {

        controls = new THREE.OrbitControls(camera, renderer.domElement);

        // 如果使用animate方法时，将此函数删除

        //controls.addEventListener( 'change', render );

        // 使动画循环使用时阻尼或自转 意思是否有惯性

        controls.enableDamping = true;

        //动态阻尼系数 就是鼠标拖拽旋转灵敏度

        //controls.dampingFactor = 0.25;

        //是否可以缩放

        controls.enableZoom = true;

        //是否自动旋转

        controls.autoRotate = false;

        //设置相机距离原点的最远距离

        controls.minDistance = 20;

        //设置相机距离原点的最远距离

        controls.maxDistance = 10000;

        //是否开启右键拖拽

        controls.enablePan = true;

    }

    //生成gui设置配置项

    var gui;

    function initGui() {

        //声明一个保存需求修改的相关数据的对象

        gui = {

            numberOfObjects: 500, //当前场景中模型的个数

            combined: false, //是否合并模型

            redraw: function () {

                //删除场景内现有的立方体

                var arr = [];

                scene.traverse(function(e){

                    if (e instanceof THREE.Mesh) arr.push(e);

                });

                arr.forEach(function(value) {

                    scene.remove(value);

                });

                //重新生成立方体

                if (gui.combined) {

                    //合并模型，则使用merge方法合并

                    var geometry = new THREE.Geometry();

                    //merge方法将两个几何对象或者Object3D里面的几何体对象合并，（使用对象的变换）将几何体的顶点，面，UV分别合并。

                    //THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge(geometry2,matrix,materialIndexOffset) instead.

                    for (var i = 0; i < gui.numberOfObjects; i++) {

                        var cube = addCube();

                        cube.updateMatrix();

                        geometry.merge(cube.geometry, cube.matrix);

                    }

                    scene.add(new THREE.Mesh(geometry, cubeMaterial));

                } else {

                    //不合并模型，则直接将模型放入

                    for (var i = 0; i < gui.numberOfObjects; i++) {

                        scene.add(addCube());

                    }

                }

            }

        };

        var datGui = new dat.GUI();

        //添加旋转功能

        datGui.add( gui, "numberOfObjects", 0, 20000 );

        datGui.add( gui, "combined" );

        datGui.add( gui, "redraw" );

        gui.redraw();

    }

    //创建立方体的方法

    var cubeMaterial = new THREE.MeshLambertMaterial({color: 0x00ff00, transparent: true, opacity: 0.8});

    function addCube() {

        var cubeSize = 1.0;

        var cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);

        var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);

        cube.castShadow = true;

        cube.position.x = -100 + Math.round(Math.random() * 200);

        cube.position.y = -100 + Math.round(Math.random() * 200);

        cube.position.z = -100 + Math.round(Math.random() * 200);

        return cube;

    }

    function render() {

        renderer.render(scene, camera);

    }

 
    //窗口变动触发的函数

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;

        camera.updateProjectionMatrix();

        render();

        renderer.setSize(window.innerWidth, window.innerHeight);

    }

    function animate() {

        //更新性能插件

        // stats.update();

        //更新控制器

        controls.update();

        render();

        requestAnimationFrame(animate);

    }

    function draw() {

        initRender();

        // initStats();

        initScene();

        initCamera();

        initLight();

        initModel();

        initControls();

        initGui();

        animate();

        window.onresize = onWindowResize;

    }

</script>

</html>